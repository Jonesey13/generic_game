#version 410 core
uniform mat4 world_view;

in vec2 c0_cs[];
in vec2 c1_cs[];
in vec2 c2_cs[];
in vec2 vert_dir_cs[];
in float bezier_width_cs[];
in vec2 pos_cs[];
in vec4 color_cs[];
in float logic_length_left_cs[];
in float logic_length_right_cs[];
in float logic_height_left_cs[];
in float logic_height_right_cs[];
in float length_cs[];
in float height_cs[];
in vec2 sub_pos_cs[];

out vec4 color_es;

vec2 map_rect_pos(vec2 uv, float length, float height, vec2 pos);
vec2 map_logical_pos(vec2 uv, float width_left, float width_right, float length_left, float length_right);
vec2 map_bezier_pos(vec2 uv, vec2 c0, vec2 c1, vec2 c2, vec2 vert_dir, float width, vec2 pos);
float logical_x_inverse(float x_pos, float length_left, float length_right);

layout(quads, equal_spacing) in;

void main() {
  vec2 bezier_param = gl_TessCoord.xy;
  color_es = color_cs[0];
  vec2 logical_rect_pos = map_rect_pos(bezier_param, length_cs[0], height_cs[0], sub_pos_cs[0]);
  vec2 regularised_rect_pos = map_logical_pos(logical_rect_pos, logic_height_left_cs[0], logic_height_right_cs[0], logic_length_left_cs[0], logic_length_right_cs[0]);
  
  gl_Position = vec4( map_bezier_pos(regularised_rect_pos, c0_cs[0], c1_cs[0], c2_cs[0], vert_dir_cs[0], bezier_width_cs[0], pos_cs[0]), 0.0, 1.0);
  //gl_Position = vec4(regularised_rect_pos, 0.0, 1.0);
  gl_Position = world_view * gl_Position;
}

vec2 map_rect_pos(vec2 uv, float length, float height, vec2 pos) {
  return (uv - vec2(0.5, 0.5))  * vec2(length, height) + pos;
}

vec2 map_logical_pos(vec2 uv, float width_left, float width_right, float length_left, float length_right) {
  float x_inv = logical_x_inverse(uv.x, length_left, length_right);
  vec2 pre_y_reg = vec2(x_inv, uv.y / ( x_inv * width_right + (1 - x_inv) * width_left));
  return vec2(max(min(pre_y_reg.x, 1.0), 0.0), max(min(pre_y_reg.y + 0.5, 1.0), 0.0));
}

vec2 map_bezier_pos(vec2 uv, vec2 c0, vec2 c1, vec2 c2, vec2 vert_dir, float width, vec2 pos) {
  float t = uv.x;
  vec2 bezier_line_pos =
    (1 - t) * (1 - t) * c0
    + 2 * t * (1 - t) * c1
    + t * t * c2;
  float vertical_pos = uv.y - 0.5;
  vec2 local_pos = bezier_line_pos + vertical_pos * width * vert_dir; 
  return local_pos + pos;
}

float logical_x_inverse(float x_pos, float length_left, float length_right) {
  if (abs(length_right - length_left) > 0.001) {
    float discriminant = length_left * length_left + 2 * (length_right - length_left) * x_pos;
    return (-length_left + sqrt(discriminant)) / (length_right - length_left);
  }
  else {
    return x_pos;
  }
}
